#!/usr/bin/env bash

# Short-circuit if confgen.sh has already been sourced
[[ $(type -t dd::confgen::loaded) == function ]] && return 0

# Define variables in file with expansion, last to sections get inserted
# verbatim.
# Arguments:
#   $1 - Source file
#   $2 - Output file. Defaults to $HOME/SOURCE_FILE
# Env:
#   $DOTDEPLOY_MESSAGES_FILE
# Outputs:
#   None. Writes to $DOTDEPLOY_MESSAGES_FILE.
dd::confgen::generate() {
    local target="$1"
    local output=${2:-$HOME/.$target}
    # loop over active modules
    local home_modules
    local sys_modules
    mapfile -t home_modules < <(dd::db::get_modules "$DOTDEPLOY_LOCAL_DB")
    mapfile -t sys_modules < <(dd::db::get_modules "$DOTDEPLOY_DB")
    local all_modules=( "${home_modules[@]}" "${sys_modules[@]}" )
    mapfile -t -d " " all_modules < <(dd::common::arr_remove_duplicates "${all_modules[@]}")

    dd::log::log-info "Generating $output"

    if [[ -f "$output" ]]; then
        rm -v "$output"
    fi

    cat <<EOF >> "$output"
# This file was auto-generated by dotdeploy.
# It is NOT safe to edit this file. Changes will be overwritten!

EOF
    local module
    for module in "${all_modules[@]}"; do
        if [[ "$module" == "hosts/"* ]]; then
            local module_path="$DOTDEPLOY_ROOT"/"$module"
        else
            local module_path="$DOTDEPLOY_MODULES_DIR/$module"
        fi
        local target_path="$module_path"/"$target"

        if [[ -f "$target_path" ]]; then

            cat <<EOF >> "$output"
# From $module
EOF

            cat "$target_path" >> "$output"

            cat <<EOF >> "$output"

EOF

        fi
    done
}


# Marker function to indicate confgen.sh has been fully sourced
dd::confgen::loaded() {
  return 0
}
