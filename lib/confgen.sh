#!/usr/bin/env bash

# Short-circuit if confgen.sh has already been sourced
[[ $(type -t dd::confgen::loaded) == function ]] && return 0


#
## Libraries
source "$(dirname "$(realpath "${BASH_SOURCE[0]}")")"/env.sh
source "$(dirname "$(realpath "${BASH_SOURCE[0]}")")"/common.sh
source "$(dirname "$(realpath "${BASH_SOURCE[0]}")")"/db.sh
source "$(dirname "$(realpath "${BASH_SOURCE[0]}")")"/log.sh


# Read source file and evaluate '##%%' tag conditions
# Arguments:
#   $1 - Source file
# Outputs:
#   Content of source file after tags have been evaluated.
dd::confgen::read_content() {
  local file="$1"
  local start_reg="^[:space:]*##%%"
  local end_reg="^[:space:]*##%% end"

  readarray -t lines < "$file"

  local include="yes"
  declare -a content
  for line in "${lines[@]}"; do
      if [[ "$line" =~ $end_reg ]]; then
          include="yes"
          continue
      fi
      if [[ "$line" =~ $start_reg ]]; then
          if ! eval "${line#\#\#%%\ }"; then
              include="no"
          fi
          continue
      fi

      if [[ $include == "yes" ]]; then
          content+=( "$line" )
      fi
  done
  printf '%s\n' "${content[@]}"
}


# Concatenate source files to a single output file. The source file is looked up
# in each deployed module.
# Arguments:
#   $1 - Source file
#   $2 - Output file. Defaults to $HOME/SOURCE_FILE
# Env:
#   $DOTDEPLOY_TMP_DIR
# Outputs:
#   None. Writes to output file.
dd::confgen::generate() {
  local source="$1"
  local output=${2:-$HOME/.$source}
  # loop over active modules
  local home_modules
  local sys_modules
  mapfile -t home_modules < <(dd::db::get_modules "$DOTDEPLOY_LOCAL_DB")
  mapfile -t sys_modules < <(dd::db::get_modules "$DOTDEPLOY_DB")
  local all_modules=( "${home_modules[@]}" "${sys_modules[@]}" )
  mapfile -t -d " " all_modules < <(dd::common::arr_remove_duplicates "${all_modules[@]}")

  dd::log::log-info "Generating $output"

  if [[ -f "$output" ]]; then
      rm -v "$output"
  fi

  mkdir -p "$DOTDEPLOY_TMP_DIR"/confgen
  local output_tmp
  output_tmp="$DOTDEPLOY_TMP_DIR"/confgen/"$(basename "$output")"

  cat <<EOF >> "$output_tmp"
# This file was auto-generated by dotdeploy.
# It is NOT safe to edit this file. Changes will be overwritten!

EOF
  local module
  for module in "${all_modules[@]}"; do
      if [[ "$module" == "hosts/"* ]]; then
          local module_path="$DOTDEPLOY_ROOT"/"$module"
      else
          local module_path="$DOTDEPLOY_MODULES_DIR/$module"
      fi
      local source_path="$module_path"/"$source"

      if [[ -f "$source_path" ]]; then

          {
            cat <<EOF
# From $module
EOF

            dd::confgen::read_content "$source_path"

            cat <<EOF

EOF
          } >> "$output_tmp"
      fi
  done
  cat -s "$output_tmp" > "$output"
}


# Marker function to indicate confgen.sh has been fully sourced
dd::confgen::loaded() {
  return 0
}
